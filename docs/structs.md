# Структуры данных

## Динамический массив

Динамический массив в простейшей реализации представляет собой выделенный операционной системой непрерывный кусок памяти, указатель на его начало и два дополнительных счётчика: ёмкость выделенной памяти (capacity), количество элементов в массиве (size).

```cpp
#include <vector>

std::vector<T>
```

Операция | Время в среднем | Время в худшем
--- | --- | ---
Обращение по индексу | O(1) | O(1)
Добавление в конец | O(1) | O(n)
Добавление на произвольную позицию | O(n) | O(n)
Удаление последнего элемента | O(1) | O(n)
Удаление произвольного элемента | O(n) | O(n)
Поиск по значению | O(n) | O(n)


## Стек

Стек — структура данных, которая позволяет быстро добавить элемент в конец и быстро получить последний элемент. В общем случае другие операции стек может либо не поддерживать, либо выполнять неэффективно.

```cpp
#include <stack>

std::stack<T, Container<T>>
```


## Очередь

Очередь реализует быстрые операции добавления в конец и извлечения из начала очереди.

```cpp
#include <queue>

std::queue<T, Container<T>>
```


## Связный список

Односвязный список — это структура данных, в которой каждый элемент имеет значение и указатель на следующий элемент. Если элемент также содержит указатель на предыдущий, то список называется двусвязным.

```cpp
#include <forward_list>
#include <list>

std::forward_list<T> // singly-linked
std::list<T> // doubly-linked
```

Когда речь идёт о списках, проще всего реализовать сортировку слиянием или вставками.

Операция | Время в среднем | Время в худшем
--- | --- | ---
Обращение по индексу | O(n) | O(n)
Добавление в конец | O(1) | O(1)
Добавление элемента на следующую позицию за текущим | O(1) | O(1)
Удаление первого элемента | O(1) | O(1)
Удаление текущего элемента | O(1) | O(1)
Поиск по значению | O(n) | O(n)


## Хеш-таблица

Хеш-таблица — это структура данных поиска. Она позволяет быстро добавлять, искать и удалять элементы. На её основе реализованы контейнеры множество и словарь.

```cpp
#include <unordered_set>
#include <unordered_map>

std::unordered_set<Key, Hash<Key>, KeyEqual<Key>>
std::unordered_multiset<Key, Hash<Key>, KeyEqual<Key>>
std::unordered_map<Key, T, Hash<Key>, KeyEqual<Key>>
std::unordered_multimap<Key, T, Hash<Key>, KeyEqual<Key>>
```

Во множествах и словарях можно хранить не только целые числа. Для этого нам пригодятся хеш-функции, то есть функции, которые принимают на вход объект и возвращают целое число. Например, бывают хеш-функции от строки или массива. Тогда номер корзинки будет вычисляться как `hash(x) % buckets.size()`.

Для эффективной работы хеш-таблицы нужно, чтобы хеш-функция хорошо перемешивала значения. Введём несколько обозначений:
Пусть U — все возможные значения, которые может принимать хеш-функция h, K — некоторый набор ключей, h(K) — множество значений хеш-функции h от ключей K.
Тогда можно неформально сказать, что h — хорошая хеш-функция, если для любого K её множество значений h(K) выглядит случайным подмножеством U.

Используйте множество, когда вам нужно быстро проверять, существует элемент в коллекции или нет.
Используйте словарь, когда вам нужно что-то считать для элементов, которые не представляют собой непрерывный отрезок целых чисел. Например, задача: дан текст, нужно посчитать число вхождений каждого слова в текст.

Операция | Время в среднем | Время в худшем
--- | --- | ---
Добавление элемента | O(1) | O(n)
Удаление элемента | O(1) | O(n)
Поиск элемента | O(1) | O(n)


## Бинарная куча и приоритетная очередь

Бинарная (двоичная) куча — структура данных, которая эффективно реализует следующие операции:

1. добавить элемент,
2. найти максимальный элемент,
3. удалить максимальный элемент.

При создании кучи можно задать параметры так, чтобы она поддерживала операции с минимальным элементом, а не максимальным.

Приоритетная очередь — абстрактная структура данных, которая предоставляет те же операции. Можно сказать, что приоритетная очередь — это интерфейс, а бинарная куча — конкретная реализация этого интерфейса.

```cpp
#include <queue>

std::priority_queue<T, Container<T>, Comparator<T> = std::less<T>>
```

Когда вы решаете задачу поиска и удаления минимума или максимума в пополняемой коллекции. Классический пример — алгоритм Дейкстры. Приоритет каждой вершины — расстояние до неё от начальной вершины. На каждом шаге мы извлекаем вершину с минимальным расстоянием. Если при рассмотрении соседей текущей вершины какие-то расстояния обновились — помещаем эти вершины в очередь.

Если в дополнение к этому вам нужно удалять произвольные элементы из коллекции, то вместо приоритетной очереди лучше использовать сбалансированное дерево поиска.

Операция | Время в среднем | Время в худшем
--- | --- | ---
Получить значение максимального элемента | O(1) | O(1)
Добавить произвольный элемент | O(log n) | O(log n)
Удалить максимальный элемент | O(log n) | O(log n)
Найти элемент по значению | O(n) | O(n)
Удалить элемент по значению | O(n) | O(n)


## Двоичное дерево поиска

Основная идея, лежащая в основе двоичного дерева поиска, заключается в том, что для любой вершины выполняется условие, которое мы сейчас опишем. Рассмотрим некоторую вершину v со значением x. В левом поддереве вершины v находятся вершины со значением, не превосходящим x, а в правом — строго больше x.

```cpp
#include <set>
#include <map>

std::set<Key, Comparator<Key> = std::less<Key>>
std::multiset<Key, Comparator<Key> = std::less<Key>>
std::map<Key, T, Comparator<Key> = std::less<Key>>
std::multimap<Key, T, Comparator<Key> = std::less<Key>>
```

Опишем алгоритм поиска некоторого значения y. Начиная с корня дерева, сравниваем значение в текущей вершине с y. Если оно равно — элемент найден, если значение в вершине меньше y, то идём в правое поддерево, иначе — в левое. Если соответствующего поддерева не существует, значит такого элемента нет в дереве.

Сложность поиска соответствует глубине дерева. Если дерево построить неудачно, то сложность будет линейная. Поэтому при вставке и удалении применяется балансировка, то есть перестроение структуры дерева таким образом, чтобы глубина всегда была логарифмическая от числа вершин.

Итак, основные операции — добавление, удаление и поиск элемента работают за O(logN). Время поиска минимального и максимального элементов зависит от реализации, но не больше O(logN).
